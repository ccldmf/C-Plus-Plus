 # 函数模板

 **函数模板：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一种特殊的函数，**可以使用不用的类型进行调用**，对于功能相同的函数，不需要重复编写代码，并且函数模板与普通函数看起来很类似，区别就是**类型可以被参数化**

格式：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template <**typename** 类型参数1，typename类型参数2，...>

其中template关键字用于**声明开始进行泛型编程**

typename关键字用于**声明泛指类型**

返回值类型  模板函数名（形参表）

{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数体

}；

Example:
```
template <typename T>            //这里的参数类型表要和模板函数明中的形参表对应。

void Swap(T& x, T& y)
{
       T tmp = x;
       x = y;
       y = tmp;
}

int main()
{
       int n = 1, m = 2;
       Swap(n,m);
       cout << "n=" << n << ",m=" << m << endl;
       double k = 4, j = 9;
       Swap(k, j);
       cout << "n=" << k << ",m=" << j << endl;
       return 0;
}
```
**特性：**

&nbsp;&nbsp;&nbsp;&nbsp;**（1）不通过参数实例化函数模板**
```
template <typename T>

T Inc(T n)
{
return 1 + n; 
}

int main()
{
cout<<**Inc<double>**(4)/2;            //结果：2.5 
return 0; 
}
```
**（2）函数模板可以重载，只要他们的形参表或类型参数表不同即可。**

**（3）匹配模板函数时，不进行类型自动转换，类型必须严格匹配。**

**注意：**

在有多个函数和函数模板名字相同的情况下，编译器如下处理；一条函数调用语句：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.先找参数完全匹配的**普通函数**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.再找参数完全匹配的**模板函数** 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.再找实参经过自动类型转换后能够匹配的**普通函数** 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4，都没有找到，则报错