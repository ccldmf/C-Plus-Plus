* 定义

​		**只有一个参数**，即对**同类对象**的**引用**。如果没有定义复制构造函数，则编译器自动生成默认复制构造函数。不允许有形如X::X(X)的构造函数

* 格式

```
        X::X(X &)
        或
        X::X(const X &)
```

* 使用场景

    * 当用一个对象去初始化同类的另一个对象

    ```
         如：
         Complex c2(c1);  
         Complex c2 = c1;   // 调用复制构造函数            
         c2 = c1;           // 调用赋值重载函数 
    ```

    * 当某函数有一个参数是类A的对象，那么该函数被调用时，类A的赋值构造函数将被调用。

    ```
        如： 
        void func(A a1) { ...} 
        int main() 
        {
        A a2; 
        func(a2); 
        }			
    ```

    * 如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。

    ```
         如：
        A func(){
        A b(4); 
        return b; 
        } 
    
        int main(){
        cout<<func().v<<endl; 
        reutrn 0; 
        } 
    ```

    **注意：**

    ​		对象间的赋值并不导致复制构造函数被调用。

    **因为调用复制构造函数的开销较大，所以考虑使用引用类型作为参数，如果希望确保实参的值在函数中不被改变，那么可以加上const关键字。** 

    

* 浅拷贝

    ​		在未定义复制构造函数的时候，调用一次默认的复制构造函数，析构函数会被调用2次，如果析构函数中有对类中申请的空间进行释放，那么会导致程序崩溃。原因是两个对象的指针在默认复制构造函数中都只是简单进行指针的拷贝，拷贝后两个指针都指向一个共同的空间，释放一次后再次释放必然崩溃。

* 深拷贝

    ​		为了解决在未定义复制构造函数情况下浅拷贝可能导致的程序崩溃问题，自定义复制构造函数，在函数中补单对指针进行拷贝，还对指针指向的内容进行拷贝，拷贝后指针指向两个不同的地址。这样析构函数的执行就不会导致程序崩溃了。