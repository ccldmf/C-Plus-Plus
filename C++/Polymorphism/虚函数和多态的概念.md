* 虚函数

    向上转型通过基类指针只能访问派生类的成员变量，不能访问派生类的成员函数，为了让基类指针能够访问派生类的成员函数，因此增加**虚函数**。

    * 在函数声明前添加**virtual**关键字，函数定义处可以加也可以不加。

    * 可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽关系的同名函数都将自动成为虚函数。

    * 在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。

    * 只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。

        例如：基类虚函数的原型为virtual void func();，派生类虚函数的原型为virtual void func(int);，那么当基类指针 p 指向派生类对象时，语句p -> func(100);将会出错，而语句p -> func();将调用基类的函数。

    * 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。

    * 析构函数可以声明为虚函数.

    有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。也就是说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态**（Polymorphism）。虚函数的唯一用处就是构成多态。

    声明虚函数条件：

    * 成员函数所在类会作为基类
    * 成员函数在类的继承后是否会更改功能
    * 如果功能会被修改，那么一般声明为虚函数
    * 如果功能不需要修改或者派生类不使用该函数，则不声明为虚函数

* 多态

    * 表现形式一

        **派生类的指针可以赋给基类指针。** 

        通过基类指针调用基类派生类中的同名虚函数时：

        * 若该指针指向一个基类的对象，那么被调用的是基类的虚函数

        * 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。

        这种机制就是“多态” 

    * 表现形式二

        **派生类的对象可以赋给基类引用。**

        通过基类引用调用基类和派生类的中的同名虚函数时：

        * 若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数

        * 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数

    * 多态构成条件

        * 必须存在继承关系
        * 继承关系中必须有同名的虚函数，并且他们是覆盖关系，即函数原型相同
        * 存在基类的指针，使用该指针调用虚函数。

    * 多态的作用

        **在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或者增加功能的时候，需要改动和增加的代码较少。**

Example:

```
class CBase {
public:
	virtual void VirtualFunction() { cout << "CBase virtual function" << endl; }
};

class CDerived:public CBase {
public:
	virtual void VritualFunction() { cout << "CDerived virtual function" << endl; }
};

int main()
{
	CDerived ODerived;
	CBase* p = &ODerived;
	p->VirtualFunction();
	return 0;
}
```
Result:

CBase virtual function