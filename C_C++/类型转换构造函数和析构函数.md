 # C++_类型转换构造函数和析构函数

**类型转换构造函数**

&nbsp;&nbsp;&nbsp;&nbsp;**目的**：实现类型的自动转换。

&nbsp;&nbsp;&nbsp;&nbsp;**特点**：只有一个参数，而且不是复制构造函数的构造函数。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要时，编译器会自动调用转换构造函数，建立一个无名的临时对象（或者临时变量）。

&nbsp;&nbsp;&nbsp;&nbsp;**调用时机：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡是需要将系统预定义的数据类型转换为类类型的都要用到转换构造函数。

**Example**:
```
       class Complex {
       public:
       double real, imag;
       Complex(int i) {
              cout << "IntConstructor called" << endl;
              real = i;
              imag = 0;
       };

       Complex(double r, double i) {
              cout << "Complex called" << endl;
              real = r;
              imag = i;
       };
    };

    int main()
    {
       Complex c1(7,8);
       Complex c2 = 12;
       c1 = 9;
       cout << c2.real << "," << c2.imag << endl;
       cout << c1.real << "," << c1.imag << endl;
       return 0;
    }
```

**析构函数**

 &nbsp;&nbsp;&nbsp;&nbsp;**定义**：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名字和类名相同，在前面加“~”，没有参数和返回值，在类消亡时执行。一个类最多只能有一个析构函数。如果定义类时没有定义析构函数，那么                 编译器会生成一个缺省的析构函数。

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象数组生命周期结束时，对象数组额每个元素的析构函数都会被调用。

 **调用时机**：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.Delete运算导致析构函数的调用。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.析构函数在对象作为函数返回值返回后被调用。