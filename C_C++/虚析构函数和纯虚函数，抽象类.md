 # C++_6-5-虚析构函数和纯虚函数，抽象类

 **1.虚析构函数：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**虚析构函数产生背景：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当派生类对象从内存中撤销时一般先运行派生类的析构函数，然后再调用基类的析构函数。如果用new运算符建立的派生类的临时对象，对指向基类的指针指向这个临时对象当用delete运算符撤销对象时，**系统执行的是基类的析构函数，而不是派生类的析构函数，不能彻底的“清理现场”**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**解决方法：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**把基类的析构函数声明为virtual,派生类的析构函数同样也是virtual，可以省去virtual不进行声明。这样删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。**

一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数，或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。

**注意：不允许以虚函数作为构造函数。**

**Example：**
```
    class son {
    public:
       ~son() { cout << "bye from son" << endl; }
    };

    class grandson :public son {
    public:
       ~grandson() { cout << "bye from grandson" << endl; }
    };

    int main()
    {
       son* pson;
       pson = new grandson();
       delete pson;
       return 0;
    }
```

 **Result:**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bye from son    //派生类的析构函数没有被执行，与期望不符。

**解决方法**：
```
    class son {
    public:
       virtual ~son() { cout << "bye from son" << endl; }
    };

    class grandson :public son {
    public:
       ~grandson() { cout << "bye from grandson" << endl; }
    };

    int main()
    {
       son* pson;
       pson = new grandson();
       delete pson;
       return 0;
    }
```

  **Result:**
```
    bye from grandson
    bye from son 
```

**2.纯虚函数：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**定义：没有函数体的虚函数。**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**格式：virtual void Print() = 0;**

**3.抽象类：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**定义：包含纯虚函数的类**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**注意：**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**（1）抽象类只能作为基类来派生新类使用，不能创建抽象类的对象。**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**（2）抽象类的指针和引用可以指向由抽象类派生出来的类的对象。**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设A是抽象类

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A a;    //错误，不能创建抽象类的对象

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A *pa;   //OK，可以定义抽象类的指针和引用

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pa = new A; //错误

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**（3）在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**（4）如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，他才能成为非抽象类。**

**Example:**
```
    class A {
    public:
       virtual void f() = 0;             //纯虚函数
       void g() { this->f(); }
       A() {  }
    };

    class B :public A {
    public:
       void f() { cout << "B:f()" << endl; }    //实现了基类中的纯虚函数
    };

    int main()
    {
       B b;
       b.g();
       return 0;
    }
```

**Result:**
```
    B:f()
```